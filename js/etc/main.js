// ----------------------------
  // WebKit Audio
  var context = new window.webkitAudioContext();
  var source = null;
  var audioBuffer = null;

  // User selects file, read it as an ArrayBuffer and pass to the API.
  var fileInput = document.querySelector('input[type="file"]');
  fileInput.addEventListener('change', function(e) {  
    var reader = new FileReader();
    reader.onload = function(e) {
      initSound(this.result);
    };
    reader.readAsArrayBuffer(this.files[0]);
  }, false);

  // Sound control functions
  function stopSound() {
    if (source) {
      source.noteOff(0);
    }
  }
  function playSound() {
    // source is global so we can call .noteOff() later.
    source = context.createBufferSource();
    source.buffer = audioBuffer;
    source.loop = false;
    source.connect(context.destination);
    source.noteOn(0); // Play immediately.
  }
  function initSound(arrayBuffer) {
    context.decodeAudioData(arrayBuffer, function(buffer) {
      // audioBuffer is global to reuse the decoded audio later.
      audioBuffer = buffer;
      var buttons = document.querySelectorAll('button');
      buttons[0].disabled = false;
      buttons[1].disabled = false;
    }, function(e) {
      console.log('Error decoding file', e);
    }); 
  }
  // Load file from a URL as an ArrayBuffer.
  // Example: loading via xhr2: loadSoundFile('sounds/test.mp3');
  function loadSoundFile(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function(e) {
      initSound(this.response); // this.response is an ArrayBuffer.
    };
    xhr.send();
  }

  function MachineGun(context) {

    var ctx = this;
    var loader = new BufferLoader(context, ['sounds/m4a1.mp3',
                                'sounds/m1-garand.mp3'], onLoaded);

    function onLoaded(buffers) {
      ctx.buffers = buffers;
    };

    loader.load();
  }
  MachineGun.prototype.shootRound = function(type, rounds, interval, random, random2) {
    if (typeof random == 'undefined') {
      random = 0;
    }
    var time = context.currentTime;
    // Make multiple sources using the same buffer and play in quick succession.
    for (var i = 0; i < rounds; i++) {
      var source = this.makeSource(this.buffers[type]);
      source.playbackRate.value = 1 + Math.random() * random2;
      source.start(time + i * interval + Math.random() * random);
    }
  }
  MachineGun.prototype.makeSource = function(buffer) {
    var source = context.createBufferSource();
    var compressor = context.createDynamicsCompressor();
    var gain = context.createGain();
    gain.gain.value = 0.2;
    source.buffer = buffer;
    source.connect(gain);
    gain.connect(compressor);
    compressor.connect(context.destination);
    return source;
  };

// Generated by CoffeeScript 1.7.1
(function() {
  var Game, game,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Game = (function(_super) {

    __extends(Game, _super);

    function Game() {

      // Game variables
      var planet = { x:480, y:atom.height/2, r:200, d:400 },
          rover = { x:0, y:0, a:0, c:0, probeHeight:planet.r, resources:0 },
          obstacles = [],
          shocks = [],
          shockCooldown = 0,
          c = atom.context;

      // Utility functions
      var detectCollision = function(o, x, y) {
        if (Math.abs(o.x-x) > o.r || Math.abs(o.y-y) > o.r) {
          return false;
        }
        else if (Math.pow(x-o.x,2)+Math.pow(y-o.y,2) > o.r*o.r) {
          return false;
        }
        else {
          return true;
        }
      };

      var drawObstacle = function(obstacle, sprites) {
        c.drawImage(
          sprites[obstacle.broken], 
          obstacle.x - obstacle.r, 
          obstacle.y - obstacle.r, 
          obstacle.r*2, 
          obstacle.r*2
        );  
      }

      Game.__super__.constructor.apply(this, arguments);
      atom.input.bind(atom.key.LEFT_ARROW, 'left');
      atom.input.bind(atom.key.RIGHT_ARROW, 'right');
      atom.input.bind(atom.key.SPACE, 'space');
      atom.input.bind(atom.key.SHIFT, 'shift');

      // Sprites
      c.emptyBoulderImg = [new Image(), new Image(), new Image()];
      c.resourceBoulderImg = [new Image(), new Image()];
      c.moonImg = new Image();
      c.carImg = new Image();
      c.moonImg.src = 'img/moon.png';
      c.carImg.src = 'img/car.png';

      // Boulder breaking sequences
      c.emptyBoulderImg[0].src = 'img/boulder1.png';
      c.emptyBoulderImg[1].src = 'img/boulder2.png';
      c.emptyBoulderImg[2].src = 'img/boulder3.png';
      c.resourceBoulderImg[0].src = 'img/boulder1.png';
      c.resourceBoulderImg[1].src = 'img/boulder4.png';

      // Setup context
      c.translate(planet.x, planet.y);

      // Setup obstacles
      obstacles.push({
        x: 50,
        y: 50,
        r: 25,
        hit: false,
        breakable: true,
        broken: 0,
        resources: 100
      });
    }

    Game.prototype.update = function(dt) {

      // Move shockwave
      if (this.shockCooldown > 40) {
        this.shocks.filter(function(shock) { return shock.on; }).forEach(function(shock) {
          shock.x += shock.dx;
          shock.y += shock.dy;
          this.obstacles.forEach(function(obstacle) {
            if (detectCollision(obstacle, shock.x, shock.y)) {
              if (obstacle.breakable) {
                shock.on = false;
                if (!obstacle.hit) {
                  obstacle.hit = true;
                  obstacle.broken = obstacle.resources > 0 ? 1 : Math.min(++obstacle.broken, 2);
                }     
              }
              else {
                shock.dx = -shock.dx;
                shock.dy = -shock.dy;
              }
            }
          });
          if (shock.x*shock.x + shock.y*shock.y > this.planet.r*this.planet.r) { shock.on = false; }
        });
        this.shockCooldown--;
      }
      else if (this.shockCooldown > 0) { 
        this.shocks = [];
      	this.shockCooldown--; 
      }

      //if (atom.input.pressed('left')) {
        //return console.log("player started moving left");
      //} else 
      if (atom.input.down('left')) {
      	this.rover.c--;
        this.rover.a = this.rover.c/20;
      	this.rover.probeHeight = this.planet.r;
      }
      if (atom.input.down('right')) {
      	this.rover.c++;
        this.rover.a = this.rover.c/20;
      	this.rover.probeHeight = this.planet.r;
      }

      // Rover probe control
      if (atom.input.down('shift')) {
        var collided = false,
            probeX = this.rover.probeHeight * Math.sin(this.rover.a),
            probeY = -this.rover.probeHeight * Math.cos(this.rover.a);

        this.obstacles.forEach(function(obstacle){
          if (detectCollision(obstacle, probeX, probeY))
          {
            if (obstacle.resources > 0)
            {
              this.rover.resources++;
              obstacle.resources--;
            }
            collided = true;
          }
        });

        if (!collided) { this.rover.probeHeight = Math.max(this.rover.probeHeight-1, 0); }
      }

      // Shockwave control
      if (atom.input.down('space')) {
      	if (shockCooldown < 1) {
          // Reset obstacle hit detection
          obstacles.forEach(function(obstacle) { obstacle.hit = false; });
      		// Shockwave!
          for(var i = 0; i < 5; i++)
          {
            var o = -rover.a + (i-2)*0.1;
            shocks.push({
              x: rover.x,
              y: rover.y,
              dx: (-rover.x)/50 + 4*Math.sin(o),
              dy: (-rover.y)/50 + 4*Math.cos(o),
              a: -o,
              on: true
            });
          }
          // Reset cooldown
      		shockCooldown = 100;
      	}
      }
    };

    Game.prototype.draw = function() {

      // Draw HUD
      c.beginPath();
      c.arc(0, -planet.y, 25, 0, 2*Math.PI, false);
      c.fillStyle = shockCooldown === 0 ? 'green' : 'red';
      c.fill();
      c.lineWidth = 3;
      c.strokeStyle = '#222';
      c.stroke();

	    // Draw planet
      c.beginPath();
      c.arc(0,0, planet.r+25, 0, 2*Math.PI, false);
      c.fillStyle = 'black';
      c.fill();
      c.drawImage(c.moonImg, -planet.r-25, -planet.r-25, planet.d+50, planet.d+50);    

      // Draw obstacles
      obstacles.forEach(function(obstacle) {
        if (obstacle.resources > -1) { drawObstacle(obstacle, resourceBoulderImg); }
        else { drawObstacle(obstacle, emptyBoulderImg); }
        
        // c.beginPath();
        // c.arc(obstacle.x,obstacle.y, obstacle.r, 0, 2 * Math.PI, false);
        // c.fillStyle = "rgb(" + (256-obstacle.broken*30) + ", " + obstacle.resources*3 + ", 0)";
        // c.fill();
      });

      // Draw shocks
      shocks.filter(function(shock){ return shock.on; }).forEach(function (shock) {
        c.translate(shock.x, shock.y);
        c.rotate(shock.a);
        c.fillStyle = 'green';
        c.fillRect(-15, -3, 30, 6);
        c.rotate(-shock.a);
        c.translate(-shock.x, -shock.y);
      });

      // Draw shockwave in SHOCK CONTEXT
     //  rotateAmount = shockA/20;
     //  c.rotate(rotateAmount);
  	  // if (shockOn) {
  	  // 	c.beginPath();
     //    c.moveTo(0, -planet.r);
     //    c.lineTo(shockY/8, -planet.r + shockY);
     //    c.lineTo(-shockY/8, -planet.r + shockY);
     //    c.closePath();
     //    c.fillStyle = "rgb(200,0,0)";
     //    c.fill();
  	  // }
  	  // c.rotate(-rotateAmount);

  	  // Draw rover in ROVER CONTEXT
  	  rover.x = Math.sin(rover.a) * planet.r;
  	  rover.y = -Math.cos(rover.a) * planet.r;
  	  c.rotate(rover.a);
  	  c.drawImage(c.carImg, -25, -planet.r - 24, 50, 25);

  	  // Draw probe
  	  c.fillStyle = 'black';
      c.fillRect(0, -planet.r, 5, planet.r - rover.probeHeight);

  	  // END ROVER CONTEXT
  	  c.rotate(-rover.a);
    };

    return Game;

  })(atom.Game);

  game = new Game;

  window.onblur = function() {
    return game.stop();
  };

  window.onfocus = function() {
    return game.run();
  };

  game.run();

}).call(this);

